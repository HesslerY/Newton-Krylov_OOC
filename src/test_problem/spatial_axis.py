"""SpatialAxis class"""

from datetime import datetime

from cf_units import Unit
from netCDF4 import Dataset
import numpy as np

from ..utils import class_name, create_dimension_exist_okay


class SpatialAxis:
    """class for spatial axis related quantities"""

    def __init__(self, axisname=None, fname=None, defn_dict=None):
        """
        Initialize SpatialAxis object, from a file or a dict defining the axis.

        The fundamental quantities defining a SpatialAxis are it layer edges.
        All other quantities are derived from these edges.

        Options for specifying edges are
        1) read them from a file, specified by fname,
        2) generate them from grid specs in dict, specified by defn_dect.

        file: assume edges variable in fname is named axis_name+"_edges"
        other fields in the input file are ignored

        dict: defn_dict is required to have the following keys
            nlevs (int): number of layers
            edge_start (float): first edge value
            edge_end (float): last edge value
            delta_ratio_max (float): maximum ratio of layer thicknesses
        """

        if (axisname is None) != (fname is None):
            msg = "either both or neither of axisname and fname can be passed"
            raise ValueError(msg)

        if (fname is None) == (defn_dict is None):
            msg = "exactly one of fname and defn_dict must be passed"
            raise ValueError(msg)

        if fname is not None:
            self.name = axisname
            with Dataset(fname, mode="r") as fptr:
                fptr.set_auto_mask(False)
                self.units = fptr.variables[axisname + "_edges"].units
                self.edges = fptr.variables[axisname + "_edges"][:]
                if hasattr(fptr, "defn_opts"):
                    self.defn_opts = getattr(fptr, "defn_opts")
        else:
            self.name = defn_dict["name"]
            self.units = defn_dict["units"]
            self.edges = self._gen_edges(defn_dict)
            defn_list = [key + "=" + "%s" % val for key, val in defn_dict.items()]
            self.defn_opts = "\n".join(defn_list)

        self.nlevs = len(self.edges) - 1
        self.bounds = np.empty((self.nlevs, 2))
        self.bounds[:, 0] = self.edges[:-1]
        self.bounds[:, 1] = self.edges[1:]
        self.mid = self.bounds.mean(axis=1)
        self.delta = self.bounds[:, 1] - self.bounds[:, 0]
        self.delta_r = 1.0 / self.delta
        self.delta_mid = np.ediff1d(self.mid)
        self.delta_mid_r = 1.0 / self.delta_mid

    def _gen_edges(self, defn_dict):
        """generate edges from grid specs in defn_dict"""

        nlevs = defn_dict["nlevs"]

        # polynomial stretching function
        # stretch_fcn(-1)=-1, stretch_fcn'(-1)=0, stretch_fcn''(-1)=0
        # stretch_fcn(1)=1, stretch_fcn'(1)=0, stretch_fcn''(1)=0
        # the mean of stretch_fcn is 0, so adding multiples of it to the thichnesses
        # doesn't change the mean thickness
        coord = np.linspace(-1.0, 1.0, nlevs)
        stretch_fcn = 0.125 * coord * (15 + coord * coord * (3 * coord * coord - 10))

        delta_avg = (defn_dict["edge_end"] - defn_dict["edge_start"]) / nlevs

        delta_ratio_max = defn_dict["delta_ratio_max"]
        if delta_ratio_max < 1.0:
            msg = "delta_ratio_max must be >= 1.0"
            raise ValueError(msg)
        # stretch_factor solves
        # (delta_avg + stretch_factor) / (delta_avg - stretch_factor) = delta_ratio_max
        stretch_factor = delta_avg * (delta_ratio_max - 1) / (delta_ratio_max + 1)

        delta = delta_avg + stretch_factor * stretch_fcn

        edges = np.empty(1 + nlevs)
        edges[0] = defn_dict["edge_start"]
        edges[1:] = defn_dict["edge_start"] + delta.cumsum()

        return edges

    def dump(self, fname, caller):
        """write axis information to a netCDF4 file"""

        with Dataset(fname, mode="w", format="NETCDF3_64BIT_OFFSET") as fptr:
            datestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            name = class_name(self) + ".dump"
            msg = datestamp + ": generated by " + name + " called from " + caller
            setattr(fptr, "history", msg)

            if hasattr(self, "defn_opts"):
                setattr(fptr, "defn_opts", self.defn_opts)

            self.dump_def(fptr)

            self.dump_write(fptr)

    def dump_def(self, fptr):
        """define dimensions and variables for dump"""

        bounds_name = self.name + "_bounds"
        edges_name = self.name + "_edges"
        delta_name = self.name + "_delta"

        # define dimensions

        create_dimension_exist_okay(fptr, self.name, self.nlevs)
        create_dimension_exist_okay(fptr, "nbnds", 2)
        create_dimension_exist_okay(fptr, edges_name, 1 + self.nlevs)

        # define variables

        fptr.createVariable(self.name, "f8", dimensions=(self.name,))
        fptr.variables[self.name].long_name = self.name + " layer midpoints"
        fptr.variables[self.name].units = self.units
        fptr.variables[self.name].bounds = bounds_name

        fptr.createVariable(bounds_name, "f8", dimensions=(self.name, "nbnds"))
        fptr.variables[bounds_name].long_name = self.name + " layer bounds"

        fptr.createVariable(edges_name, "f8", dimensions=(edges_name,))
        fptr.variables[edges_name].long_name = self.name + " layer edges"
        fptr.variables[edges_name].units = self.units

        fptr.createVariable(delta_name, "f8", dimensions=(self.name,))
        fptr.variables[delta_name].long_name = self.name + " layer thickness"
        fptr.variables[delta_name].units = self.units

    def dump_write(self, fptr):
        """write variables for dump"""

        bounds_name = self.name + "_bounds"
        edges_name = self.name + "_edges"
        delta_name = self.name + "_delta"

        fptr.variables[self.name][:] = self.mid
        fptr.variables[bounds_name][:] = self.bounds
        fptr.variables[edges_name][:] = self.edges
        fptr.variables[delta_name][:] = self.delta

    def int_vals_mid(self, vals):
        """
        integral of vals at layer midpoints
        works for multiple tracer values, assuming vertical axis is last
        """
        return (self.delta * vals).sum(axis=-1)

    def int_vals_mid_units(self, vals_units):
        """units of int_vals_mid result, assuming units of vals are vals_units"""
        units_out_list = vals_units.split()
        for ind, term in enumerate(units_out_list):
            if _is_power_of(term, self.units):
                units_out_list[ind] = Unit(term + " " + self.units).format()
                return " ".join(units_out_list)
        units_out_list.append(self.units)
        return " ".join(units_out_list)


def _is_power_of(term1, term2):
    """is term1 convertible from a power of term2"""
    for power in range(-6, 7):
        term2_raised = "(%s)%d" % (term2, power)
        if Unit(term1).is_convertible(term2_raised):
            return True
    return False
